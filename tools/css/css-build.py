#!/usr/bin/env python3
"""
CSS Build System
Concatenates modular CSS files in correct order and validates the output.
"""

import os
import json
import hashlib
from pathlib import Path
from typing import List, Dict, Any
import argparse
from datetime import datetime

class CSSBuilder:
    """Build system for concatenating and validating modular CSS files."""
    
    def __init__(self, styles_dir: str = "app/src/main/assets/styles"):
        self.styles_dir = Path(styles_dir)
        self.modules_dir = self.styles_dir / "modules"
        self.output_dir = self.styles_dir
        
        # Default build order (can be overridden by config)
        self.default_build_order = [
            "base.css",
            "typography.css",
            "layout.css",
            "tables.css",
            "forms.css",
            "media.css",
            "navigation.css",
            "messagebox.css",
            "gaming.css",
            "mediawiki.css",
            "interactive.css",
            "other.css"
        ]
        
    def load_build_config(self, config_file: str = None) -> Dict[str, Any]:
        """Load build configuration from JSON file."""
        if config_file and Path(config_file).exists():
            with open(config_file, 'r') as f:
                return json.load(f)
        
        # Default configuration
        return {
            "build_order": self.default_build_order,
            "output_file": "wiki-integration.css",
            "include_source_maps": False,
            "minify": False,
            "validate": True,
            "header_comment": True
        }
    
    def get_file_hash(self, file_path: Path) -> str:
        """Get MD5 hash of a file."""
        if not file_path.exists():
            return ""
        
        with open(file_path, 'rb') as f:
            return hashlib.md5(f.read()).hexdigest()
    
    def generate_header_comment(self, config: Dict[str, Any], modules: List[str]) -> str:
        """Generate header comment for the built CSS file."""
        if not config.get("header_comment", True):
            return ""
        
        header = [
            "/*",
            " * WIKI INTEGRATION CSS - AUTO-GENERATED",
            f" * Generated: {datetime.now().isoformat()}",
            " * ",
            " * This file is automatically generated from modular CSS files.",
            " * DO NOT EDIT DIRECTLY - Edit the source modules instead.",
            " * ",
            " * Build order:"
        ]
        
        for i, module in enumerate(modules, 1):
            header.append(f" *   {i}. {module}")
            
        header.extend([
            " * ",
            " * To rebuild: python tools/css/css-build.py",
            " */"
        ])
        
        return '\n'.join(header) + '\n\n'
    
    def validate_css_syntax(self, content: str) -> List[str]:
        """Basic CSS syntax validation."""
        errors = []
        lines = content.split('\n')
        
        brace_count = 0
        in_comment = False
        
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            
            # Skip empty lines
            if not line:
                continue
                
            # Track multi-line comments
            if '/*' in line and not in_comment:
                in_comment = True
            if '*/' in line and in_comment:
                in_comment = False
                continue
            if in_comment:
                continue
                
            # Remove single-line comments for validation
            if '/*' in line and '*/' in line:
                line = line.split('/*')[0] + line.split('*/')[-1]
            
            # Count braces
            brace_count += line.count('{') - line.count('}')
            
            # Check for common syntax errors
            if line.endswith(';') and '{' not in line and '}' not in line and ':' not in line:
                errors.append(f"Line {line_num}: Suspicious semicolon without property")
            
            if line.count('{') > 1:
                errors.append(f"Line {line_num}: Multiple opening braces")
                
            if line.count('}') > 1:
                errors.append(f"Line {line_num}: Multiple closing braces")
        
        if brace_count != 0:
            errors.append(f"Unmatched braces: {brace_count} extra opening braces" if brace_count > 0 else f"{-brace_count} extra closing braces")
        
        return errors
    
    def build_css(self, config_file: str = None) -> Dict[str, Any]:
        """Build CSS from modular files."""
        config = self.load_build_config(config_file)
        
        # Check if modules directory exists
        if not self.modules_dir.exists():
            print(f"Modules directory not found: {self.modules_dir}")
            print("Run css-extractor.py first to create modular files.")
            return {"success": False, "error": "Modules directory not found"}
        
        # Find available modules
        available_modules = []
        module_info = {}
        
        for module_name in config["build_order"]:
            module_path = self.modules_dir / module_name
            if module_path.exists():
                available_modules.append(module_name)
                module_info[module_name] = {
                    "path": str(module_path),
                    "size": module_path.stat().st_size,
                    "hash": self.get_file_hash(module_path)
                }
            else:
                print(f"Warning: Module not found: {module_name}")
        
        if not available_modules:
            return {"success": False, "error": "No modules found to build"}
        
        print(f"Building CSS from {len(available_modules)} modules...")
        
        # Concatenate modules
        output_content = []
        
        # Add header
        header = self.generate_header_comment(config, available_modules)
        if header:
            output_content.append(header)
        
        # Add each module
        for module_name in available_modules:
            module_path = self.modules_dir / module_name
            
            try:
                with open(module_path, 'r', encoding='utf-8') as f:
                    module_content = f.read()
                
                # Add module separator comment
                separator = f"\n/* ===== {module_name.upper().replace('.CSS', '')} MODULE ===== */\n"
                output_content.append(separator)
                output_content.append(module_content)
                
                print(f"Added: {module_name} ({module_info[module_name]['size']} bytes)")
                
            except Exception as e:
                error_msg = f"Error reading module {module_name}: {e}"
                print(error_msg)
                return {"success": False, "error": error_msg}
        
        # Combine content
        final_content = '\n'.join(output_content)
        
        # Validate if requested
        validation_errors = []
        if config.get("validate", True):
            validation_errors = self.validate_css_syntax(final_content)
            if validation_errors:
                print(f"\n⚠️  CSS Validation warnings:")
                for error in validation_errors[:10]:  # Limit to first 10
                    print(f"  {error}")
                if len(validation_errors) > 10:
                    print(f"  ... and {len(validation_errors) - 10} more warnings")
        
        # Write output file
        output_file = self.output_dir / config["output_file"]
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(final_content)
        except Exception as e:
            error_msg = f"Error writing output file: {e}"
            print(error_msg)
            return {"success": False, "error": error_msg}
        
        # Generate build manifest
        manifest = {
            "build_date": datetime.now().isoformat(),
            "output_file": str(output_file),
            "output_size": len(final_content),
            "output_lines": final_content.count('\n'),
            "modules_built": len(available_modules),
            "modules": module_info,
            "build_order": available_modules,
            "validation_warnings": len(validation_errors),
            "config_used": config
        }
        
        manifest_file = Path("tools/css/output/build_manifest.json")
        manifest_file.parent.mkdir(parents=True, exist_ok=True)
        with open(manifest_file, 'w') as f:
            json.dump(manifest, f, indent=2)
        
        print(f"\n✅ CSS build completed successfully!")
        print(f"Output: {output_file}")
        newline_count = final_content.count('\n')
        print(f"Size: {len(final_content):,} characters ({newline_count:,} lines)")
        print(f"Modules: {len(available_modules)}")
        print(f"Manifest: {manifest_file}")
        
        if validation_errors:
            print(f"Validation warnings: {len(validation_errors)}")
        
        return {"success": True, "manifest": manifest}
    
    def create_default_config(self, output_file: str = "tools/css/css-build-config.json"):
        """Create a default build configuration file."""
        config = {
            "build_order": self.default_build_order,
            "output_file": "wiki-integration.css",
            "include_source_maps": False,
            "minify": False,
            "validate": True,
            "header_comment": True,
            "description": "CSS build configuration for wiki-integration.css"
        }
        
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        with open(output_file, 'w') as f:
            json.dump(config, f, indent=2)
        
        print(f"Created default build config: {output_file}")
        return config
    
    def clean_build(self):
        """Clean build artifacts."""
        output_file = self.output_dir / "wiki-integration.css"
        manifest_file = Path("tools/css/output/build_manifest.json")
        
        files_removed = []
        for file_path in [output_file, manifest_file]:
            if file_path.exists():
                file_path.unlink()
                files_removed.append(str(file_path))
        
        if files_removed:
            print(f"Cleaned build artifacts:")
            for file in files_removed:
                print(f"  Removed: {file}")
        else:
            print("No build artifacts to clean.")

def main():
    parser = argparse.ArgumentParser(description="Build CSS from modular files")
    parser.add_argument("--config", help="Build configuration file")
    parser.add_argument("--create-config", action="store_true",
                       help="Create default build configuration")
    parser.add_argument("--clean", action="store_true",
                       help="Clean build artifacts")
    parser.add_argument("--styles-dir", default="app/src/main/assets/styles",
                       help="Styles directory")
    
    args = parser.parse_args()
    
    builder = CSSBuilder(args.styles_dir)
    
    if args.create_config:
        builder.create_default_config()
        return
    
    if args.clean:
        builder.clean_build()
        return
    
    # Build CSS
    result = builder.build_css(args.config)
    
    if not result["success"]:
        print(f"❌ Build failed: {result['error']}")
        exit(1)

if __name__ == "__main__":
    main()